#pragma once

#include "ClientSession/SessionManager.hpp"
#include "SDCConstants.hpp"
#include "datamodel/ws-addressing.hpp"
#include "datamodel/ws-eventing.hpp"
#include <chrono>
#include <map>
#include <mutex>
#include <string>
#include <vector>

struct esp_http_client;
namespace BICEPS::MM
{
  class EpisodicMetricReport;
  class EpisodicComponentReport;
} // namespace BICEPS::MM

/// @brief SubscriptionManager manages subscriptions in terms of ws-eventing
class SubscriptionManager
{
public:
  /// @brief Constructs a new SubscriptionManager
  /// @param useTls whether to use TLS encrypted communication
  explicit SubscriptionManager(bool use_tls);
  /// @brief dispatches a subscribe request, registers the new subscriber and creates a client
  /// session
  /// @param subscribeRequest the request the client send to subscribe
  /// @return the response generated by processing the subscription request
  WS::EVENTING::SubscribeResponse dispatch(const WS::EVENTING::Subscribe& subscribe_request);

  /// @brief dispatches a renew request and extends the duration of a subscription
  /// @param renewRequest the request the client send to renew
  /// @param identifier the identifier identifying the subscription to renew
  /// @return the response generated by processing the renew request
  WS::EVENTING::RenewResponse dispatch(const WS::EVENTING::Renew& renew_request,
                                       const WS::EVENTING::Identifier& identifier);

  /// @brief dispatches a unsubscribe request and removes the given subscriber from the list of
  /// active subscriptions
  /// @param unsubscribeRequest the request the subscriber sent to unsubscribe
  /// @param identifier the identifier identifying the subscription to remove
  void dispatch(const WS::EVENTING::Unsubscribe& unsubscribe_request,
                const WS::EVENTING::Identifier& identifier);

  /// @brief triggers an event with given report by notifying all subscribers of this event
  /// @param report the report to notify about
  void fire_event(const BICEPS::MM::EpisodicMetricReport& report);

  /// @brief triggers an event with given report by notifying all subscribers of this event
  /// @param report the report to notify about
  void fire_event(const BICEPS::MM::EpisodicComponentReport& report);

private:
  /// @brief SubscriptionInformation stores stateful information about a subscription
  struct SubscriptionInformation
  {
    /// the address of the subscriber
    const WS::ADDRESSING::EndpointReferenceType notify_to;
    /// the ws eventing filter of this subscripiton
    const WS::EVENTING::FilterType filter;
    /// the time this subscription is valid for
    Duration::TimePoint expiration_time;
  };

  /// mutex protecting subscriptions_ map
  mutable std::mutex subscription_mutex_;
  /// active subscriptions of the subscriber with a unique identifier
  std::map<std::string, SubscriptionInformation> subscriptions_;
  /// a pointer to the SessionManager implementation
  SessionManager session_manager_;
  /// all allowed subscriptions of this manager
  std::vector<std::string> allowed_subscription_event_actions_{
      SDC::ACTION_OPERATION_INVOKED_REPORT,
      SDC::ACTION_PERIODIC_ALERT_REPORT,
      SDC::ACTION_EPISODIC_ALERT_REPORT,
      SDC::ACTION_EPISODIC_COMPONENT_REPORT,
      SDC::ACTION_PERIODIC_COMPONENT_REPORT,
      SDC::ACTION_EPISODIC_METRIC_REPORT,
      SDC::ACTION_PERIODIC_METRIC_REPORT,
      SDC::ACTION_EPISODIC_OPERATIONAL_STATE_REPORT,
      SDC::ACTION_PERIODIC_OPERATIONAL_STATE_REPORT,
      SDC::ACTION_DESCRIPTION_MODIFICATION_REPORT,
      SDC::ACTION_EPISODIC_CONTEXT_REPORT,
      SDC::ACTION_WAVEFORM_STREAM,
  };

  /// @brief prints all current subscriptions to DEBUG Log
  void print_subscriptions() const;
};
